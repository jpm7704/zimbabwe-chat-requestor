
import { Request, RequestStatus, RequestType, Document as RequestDocument, TimelineEvent } from "@/types";
import { supabase } from "@/integrations/supabase/client";
import { delay } from "./baseApi";

/**
 * Create a new request
 */
export const createRequest = async (
  requestData: {
    type: RequestType;
    title: string;
    description: string;
  }
): Promise<{ requestId: string, ticketNumber: string }> => {
  try {
    const { data: session } = await supabase.auth.getSession();
    if (!session.session?.user) {
      throw new Error("No user is logged in");
    }

    const userId = session.session.user.id;

    // Generate a temporary ticket number for insertion
    // The actual ticket number will be generated by the database trigger
    const tempTicketNumber = `TEMP-${Date.now()}`;

    // Insert the request into the database with a temporary ticket number
    // The database trigger will override this with the correct format
    const { data, error } = await supabase
      .from('requests')
      .insert({
        user_id: userId,
        type: requestData.type,
        title: requestData.title,
        description: requestData.description,
        status: 'submitted' as RequestStatus,
        ticket_number: tempTicketNumber  // Added this field to satisfy TypeScript
      })
      .select('id, ticket_number')
      .single();

    if (error) {
      console.error("Error creating request:", error);
      throw error;
    }

    return { 
      requestId: data.id, 
      ticketNumber: data.ticket_number 
    };
  } catch (error) {
    console.error("Error in createRequest:", error);
    throw error;
  }
};

/**
 * Upload a document for a request
 */
export const uploadDocument = async (
  requestId: string,
  file: File,
  documentType: string
): Promise<RequestDocument> => {
  await delay(1500);
  
  // In a real app, this would upload to a server
  const documentId = Math.random().toString(36).substring(2, 10);
  
  return {
    id: documentId,
    requestId,
    name: file.name,
    type: documentType as any,
    url: URL.createObjectURL(file), // In a real app, this would be a server URL
    uploadedAt: new Date().toISOString()
  };
};

/**
 * Update a request's status
 */
export const updateRequestStatus = async (
  requestId: string,
  status: RequestStatus,
  note?: string
): Promise<TimelineEvent> => {
  await delay(800);
  
  const timelineEvent: TimelineEvent = {
    id: Math.random().toString(36).substring(2, 10),
    requestId,
    type: "status_change",
    description: `Request status updated to ${status.replace('_', ' ')}`,
    createdAt: new Date().toISOString(),
    createdBy: {
      id: "system",
      name: "System",
      role: "system"
    },
    metadata: {
      oldStatus: "submitted", // Mock previous status
      newStatus: status,
      note
    }
  };
  
  return timelineEvent;
};

/**
 * Add a note to a request
 */
export const addNoteToRequest = async (
  requestId: string,
  content: string,
  isInternal: boolean = false
): Promise<{ note: any, timelineEvent: TimelineEvent }> => {
  await delay(500);
  
  const noteId = Math.random().toString(36).substring(2, 10);
  
  const note = {
    id: noteId,
    requestId,
    authorId: "current_user", // In a real app, this would be the current user's ID
    authorName: "John Doe", // Mock name
    authorRole: "user", // Mock role
    content,
    createdAt: new Date().toISOString(),
    isInternal
  };
  
  const timelineEvent: TimelineEvent = {
    id: Math.random().toString(36).substring(2, 10),
    requestId,
    type: "note_added",
    description: `New note added ${isInternal ? '(Internal)' : ''}`,
    createdAt: new Date().toISOString(),
    createdBy: {
      id: "current_user",
      name: "John Doe",
      role: "user"
    },
    metadata: {
      noteId,
      isInternal
    }
  };
  
  return { note, timelineEvent };
};
